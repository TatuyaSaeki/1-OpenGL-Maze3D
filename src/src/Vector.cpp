//===========================================================================
//!
//!	@file	Vector.cpp
//!	@brief	ベクトル
//!
//===========================================================================
#include "stdafx.h"

//===========================================================================
//	３要素ベクトル構造体
//===========================================================================

const Vector3 Vector3::ZERO(0.0f, 0.0f, 0.0f);
const Vector3 Vector3::ONE(1.0f, 1.0f, 1.0f);

const Vector3 Vector3::AXIS_X(1.0f, 0.0f, 0.0f);
const Vector3 Vector3::AXIS_Y(0.0f, 1.0f, 0.0f);
const Vector3 Vector3::AXIS_Z(0.0f, 0.0f, 1.0f);


//---------------------------------------------------------------------------
// デフォルトコンストラクタ
//---------------------------------------------------------------------------
Vector3::Vector3()
{

}

//---------------------------------------------------------------------------
// コンストラクタ (xyz指定)
//!	@param	[in]	x		X値
//!	@param	[in]	y		Y値
//!	@param	[in]	z		Z値
//---------------------------------------------------------------------------
Vector3::Vector3(f32 x, f32 y, f32 z)
{
	_x = x;
	_y = y;
	_z = z;
}

//---------------------------------------------------------------------------
// コンストラクタ
//!	@param	[in]	v		ベクトル値
//---------------------------------------------------------------------------
Vector3::Vector3(const Vector3& v)
{
	_x = v._x;
	_y = v._y;
	_z = v._z;
}

//---------------------------------------------------------------------------
// コンストラクタ
//!	@param	[in]	v		ベクトル値
//---------------------------------------------------------------------------
Vector3::Vector3(const Vector4& v)
{
	_x = v._x;
	_y = v._y;
	_z = v._z;
}

//---------------------------------------------------------------------------
//!	代入
//---------------------------------------------------------------------------
Vector3&	Vector3::operator = (const Vector3& v)
{
	_x = v._x;
	_y = v._y;
	_z = v._z;

	return *this;
}

//---------------------------------------------------------------------------
//! 代入
//---------------------------------------------------------------------------
Vector3& Vector3::operator = (const Vector4& v)
{
	_x = v._x;
	_y = v._y;
	_z = v._z;

	return *this;
}

//---------------------------------------------------------------------------
//! 正の値
//---------------------------------------------------------------------------
Vector3		Vector3::operator + () const
{
	return *this;
}

//---------------------------------------------------------------------------
// 負の値
//---------------------------------------------------------------------------
Vector3		Vector3::operator - () const
{
	return *this * -1.0f;
}

//---------------------------------------------------------------------------
// 加算
//---------------------------------------------------------------------------
Vector3	Vector3::operator + (const Vector3& v) const
{
	Vector3		result;
	result._x = _x + v._x;
	result._y = _y + v._y;
	result._z = _z + v._z;

	return result;
}

//---------------------------------------------------------------------------
// 減算
//---------------------------------------------------------------------------
Vector3 Vector3::operator - (const Vector3& v) const
{
	Vector3		result;
	result._x = _x - v._x;
	result._y = _y - v._y;
	result._z = _z - v._z;

	return result;
}

//---------------------------------------------------------------------------
// 乗算
//---------------------------------------------------------------------------
Vector3	Vector3::operator * (const Vector3& v) const
{
	Vector3		result;
	result._x = _x * v._x;
	result._y = _y * v._y;
	result._z = _z * v._z;

	return result;
}

//---------------------------------------------------------------------------
// スケーリング
//---------------------------------------------------------------------------
Vector3 Vector3::operator * (f32 scale) const
{
	Vector3		result;
	result._x = _x * scale;
	result._y = _y * scale;
	result._z = _z * scale;

	return result;
}

//---------------------------------------------------------------------------
// スケーリング
//---------------------------------------------------------------------------
Vector3 Vector3::operator / (f32 scale) const
{
	Vector3		result;
	f32		invScale = 1.0f / scale;	
	result._x = _x * invScale;
	result._y = _y * invScale;
	result._z = _z * invScale;

	return result;
}
	
//---------------------------------------------------------------------------
// 加算
//---------------------------------------------------------------------------
Vector3&	Vector3::operator += (const Vector3& v)
{
	_x += v._x;
	_y += v._y;
	_z += v._z;

	return *this;
}

//---------------------------------------------------------------------------
// 減算
//---------------------------------------------------------------------------
Vector3& Vector3::operator -= (const Vector3& v)
{
	_x -= v._x;
	_y -= v._y;
	_z -= v._z;

	return *this;
}

//---------------------------------------------------------------------------
// スケーリング
//---------------------------------------------------------------------------
Vector3& Vector3::operator *= (f32 scale)
{
	_x *= scale;
	_y *= scale;
	_z *= scale;

	return *this;
}

//---------------------------------------------------------------------------
// スケーリング
//---------------------------------------------------------------------------
Vector3& Vector3::operator /= (f32 scale)
{
	f32		invScale = 1.0f / scale;	

	return operator *= (invScale);
}

//---------------------------------------------------------------------------
// 長さの２乗
//---------------------------------------------------------------------------
f32	Vector3::lengthSq() const
{
	return _x*_x + _y*_y + _z*_z;
}

//---------------------------------------------------------------------------
// ベクトルの長さ
//---------------------------------------------------------------------------
f32	Vector3::length() const
{
	f32	L = lengthSq();		// 長さの二乗
	if( L == 0.0f ) {
		return 0.0f;
	}
	return sqrtf(L);
}

//---------------------------------------------------------------------------
// 正規化
//---------------------------------------------------------------------------
Vector3	Vector3::normalize() const
{
	f32	L = lengthSq();		// 長さの2乗を求める

	// 長さが0.0なら自分自身のベクトルの長さは0.0になっている。
	if( L == 0.0f ) {
		return *this;
	}
	return *this / sqrtf(L);
}


//---------------------------------------------------------------------------
//	内積
//---------------------------------------------------------------------------
f32	Vector3::dot(Vector3 a, Vector3 b)
{
	return (a._x * b._x) + (a._y * b._y) + (a._z * b._z);
}

f32	Vector3::fdot(float a, float b)
{
	return (a * b) + (a * b) + (a * b);
}

//---------------------------------------------------------------------------
//	外積
//---------------------------------------------------------------------------
Vector3	Vector3::cross(Vector3 a, Vector3 b)
{
	Vector3	result;

	result._x = (a._y * b._z) - (a._z * b._y);
	result._y = (a._z * b._x) - (a._x * b._z);
	result._z = (a._x * b._y) - (a._y * b._x);

	return result;
}

//---------------------------------------------------------------------------
//! 座標変換(平行移動あり)
//---------------------------------------------------------------------------
Vector4 Vector3::transform(const Matrix& matrix)
{
	Vector4	result;

	result._x = (_x * matrix._m[0][0]) +
				(_y * matrix._m[1][0]) +
				(_z * matrix._m[2][0]) +
				(     matrix._m[3][0]);

	result._y = (_x * matrix._m[0][1]) +
				(_y * matrix._m[1][1]) +
				(_z * matrix._m[2][1]) +
				(     matrix._m[3][1]);

	result._z = (_x * matrix._m[0][2]) +
				(_y * matrix._m[1][2]) +
				(_z * matrix._m[2][2]) +
				(     matrix._m[3][2]);

	result._w = (_x * matrix._m[0][3]) +
				(_y * matrix._m[1][3]) +
				(_z * matrix._m[2][3]) +
				(     matrix._m[3][3]);

	return result;
}

//---------------------------------------------------------------------------
//! 座標変換(ベクトルの回転。平行移動なし)
//---------------------------------------------------------------------------
Vector3 Vector3::transformNormal(const Matrix& matrix)
{
	Vector3	result;

	result._x = (_x * matrix._m[0][0]) +
				(_y * matrix._m[1][0]) +
				(_z * matrix._m[2][0]);

	result._y = (_x * matrix._m[0][1]) +
				(_y * matrix._m[1][1]) +
				(_z * matrix._m[2][1]);

	result._z = (_x * matrix._m[0][2]) +
				(_y * matrix._m[1][2]) +
				(_z * matrix._m[2][2]);

	return result;
}

//===========================================================================
//	EOF
//===========================================================================
